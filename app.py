# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iZAhvWxKtG9bwOqnmOTMmAVAHvVlSW__
"""



# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# # ==========================================================
# # CÓDIGO FINAL Y CORREGIDO PARA app.py
# # ==========================================================
# 
# # 1. IMPORTACIONES
# import streamlit as st
# from PIL import Image
# import numpy as np
# import tensorflow as tf
# from tensorflow.keras.preprocessing import image
# import matplotlib.pyplot as plt
# import io
# 
# # --- Configuración de la Página ---
# st.set_page_config(
#     page_title="Detector de Fracturas",
#     page_icon="🦴",
#     layout="centered"
# )
# 
# st.title("Sistema de Detección de Fracturas Óseas")
# 
# # --- FUNCIONES DE MACHINE LEARNING ---
# 
# @st.cache_resource
# def load_keras_model():
#     """Carga el modelo Keras desde el disco."""
#     try:
#         model_path = '/content/drive/MyDrive/ColabNotebooks/TFM/fracture_detection_model/fracture_detection_model.keras'
#         model = tf.keras.models.load_model(model_path)
#         print("Modelo Keras cargado exitosamente.")
#         return model
#     except Exception as e:
#         st.error(f"Error crítico al cargar el modelo: {e}")
#         return None
# 
# def preprocess_image_from_pil(pil_image, target_size=(224, 224)):
#     img = pil_image.resize(target_size).convert('RGB')
#     img_array = image.img_to_array(img)
#     img_array = np.expand_dims(img_array, axis=0) / 255.0
#     return img_array
# 
# def classify_image(preprocessed, model):
#     class_indices = {'fractured': 0, 'not fractured': 1}
#     prediction = model.predict(preprocessed)[0][0]
#     idx_to_class = {v: k for k, v in class_indices.items()}
#     return idx_to_class.get(1 if prediction > 0.5 else 0, "Unknown")
# 
# def make_gradcam_heatmap(img_array, model, last_conv_layer_name="block_16_project"):
#     grad_model = tf.keras.models.Model([model.inputs], [model.get_layer(last_conv_layer_name).output, model.output])
#     with tf.GradientTape() as tape:
#        conv_outputs, predictions = grad_model(img_array)
#        loss = predictions[:, 0]
#     grads = tape.gradient(loss, conv_outputs)
#     pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))
#     heatmap = conv_outputs[0] @ pooled_grads[..., tf.newaxis]
#     heatmap = tf.squeeze(heatmap)
#     return tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
# 
# # --- CORRECCIÓN DEL NameError ---
# # El argumento se llama 'original_pil', así que usamos ese nombre dentro de la función.
# def get_gradcam_image(original_pil, preprocessed_img, model):
#     heatmap = make_gradcam_heatmap(preprocessed_img, model)
#     img_array = image.img_to_array(original_pil) # <-- Usamos 'original_pil'
#     heatmap = np.uint8(255 * heatmap)
#     jet = plt.colormaps.get_cmap("jet")
#     jet_colors = jet(np.arange(256))[:, :3]
#     jet_heatmap = image.array_to_img(jet_colors[heatmap]).resize((img_array.shape[1], img_array.shape[0]))
#     superimposed_img = Image.fromarray(np.clip((image.img_to_array(jet_heatmap) * 0.4) + img_array, 0, 255).astype(np.uint8))
#     return superimposed_img
# 
# 
# # --- Lógica de la Interfaz de Usuario ---
# 
# # model = load_keras_model()
# 
# # if model:
# #    uploaded_file = st.file_uploader(
# #        "Sube una radiografía para analizar", type=["png", "jpg", "jpeg"]
# #    )
# #
# #    if uploaded_file is not None:
# #        original_image = Image.open(uploaded_file)
# #        # --- CORRECCIÓN DE LA ADVERTENCIA ---
# #        # Cambiamos use_column_width a use_container_width
# #        st.image(original_image, caption="Imagen Subida", use_container_width=True)
# #
# #        if st.button("Analizar Imagen"):
# #            with st.spinner('Procesando...'):
# #                preprocessed_image = preprocess_image_from_pil(original_image)
# #                prediction = classify_image(preprocessed_image, model)
# #                gradcam_result_image = get_gradcam_image(original_image, preprocessed_image, model)
# #
# #                st.success(f"**Predicción del Modelo:** {prediction}")
# #                # --- CORRECCIÓN DE LA ADVERTENCIA ---
# #                st.image(gradcam_result_image, caption="Análisis con Grad-CAM", use_container_width=True)
# st.write("¡La aplicación base funciona!")
